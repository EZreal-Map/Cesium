<!doctype html>
<html>

<head>
    <title>张家板桥</title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />

    <link rel="stylesheet" type="text/css" href="./Cesium-1.96/Build/Cesium/Widgets/widgets.css">
    <script type="text/javascript" src="./Cesium-1.96/Build/Cesium/Cesium.js"></script>
    <style>
        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .cesium-widget-credits {
            display: none !important;
        }
    </style>

<body>
    <div id="cesiumcontainer" style="width:100%;height:100%"></div>

    <script type="text/javascript">
        Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlODBjMmY1YS00NjZjLTQwZjUtYTVhNy05NDBiODliYWYwMzUiLCJpZCI6MTU1ODM0LCJpYXQiOjE2OTAwOTA4MTN9.s-rWLcdw5_e2j9Fz2l41ydsl23lAVJg2Q3XhThRUeRM";

        var viewer = new Cesium.Viewer("cesiumcontainer", {
            //搜索框
            geocoder: false,
            //home键
            homeButton: false,
            // 动画控件
            animation: false,
            //全屏按钮
            fullscreenButton: false,
            //场景模式选择器
            sceneModePicker: false,
            //时间轴
            timeline: false,
            //导航提示
            navigationHelpButton: false,
            //地图选择器
            baseLayerPicker: false,
            // imageryProvider: new Cesium.UrlTemplateImageryProvider({
            //     url: "http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}",
            //     minimumLevel: 1,
            //     maximumLevel: 18
            // }),
        })
        // viewer.imageryLayers.add(
        //     new Cesium.ImageryLayer(new Cesium.UrlTemplateImageryProvider({
        //         url: "https://wprd01.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scl=1&style=8&ltype=4",
        //         minimumLevel: 1,
        //         maximumLevel: 18
        //     }))
        // )

        viewer.terrainProvider = new Cesium.CesiumTerrainProvider({
            url: "./terrain/",
        })

        // 将视角定位到指定的经纬度
        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(113.39811, 31.699212, 4000.0), // 例如：1000
            orientation: {
                heading: Cesium.Math.toRadians(0.0), // 指定航向角度
                pitch: Cesium.Math.toRadians(-90.0), // 指定俯仰角度
                roll: 0.0 // 指定翻滚角度
            }
        })


        // 生成Cesium颜色渐变数组，从浅蓝色到深蓝色
        const numSegments = 9;
        const startColor = "rgb(149, 208, 238)";
        const endColor = "rgb(10,9,145)";

        const colorGradient = generateCesiumColorGradient(numSegments, startColor, endColor);
        console.log(colorGradient[0]);

        // 读取center1.txt文件并加载数据为点数据几何对象
        fetch('./flood/clearcenter1dem.txt')
            .then(response => response.text())
            .then(data => {
                const lines = data.split('\n');
                for (const line of lines) {
                    const [longitude, latitude, height, dem] = line.split(',');


                    // 创建点数据几何对象
                    if (Number(height) >= 1) {
                        // var pos = Cesium.Cartographic.fromDegrees(longitude, latitude);
                        // Cesium.sampleTerrainMostDetailed(viewer.terrainProvider, [pos]).then(updates => {
                        //     console.log(updates);
                        // var updates[0]['height'] = 60;
                        const point = viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(Number(longitude), Number(latitude), Number(height) + Number(dem)),
                            point: {
                                pixelSize: 5,
                                // color: Cesium.Color.RED,
                                color: colorGradient[getIntervalIndex(height)]
                                // outlineColor: Cesium.Color.WHITE,
                                // outlineWidth: 2
                            },
                            // 设置高度参考为相对于地形表面
                            // heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                        });
                        // })
                    }
                    // 可以根据需要给每个点添加其他属性或操作
                    // point.name = 'Some name';
                    // point.description = 'Some description';
                }
            });




        function generateCesiumColorGradient(numSegments, startColor, endColor) {
            // 将RGB颜色转换为Cesium颜色
            function rgbToCesiumColor(r, g, b) {
                return new Cesium.Color(r / 255, g / 255, b / 255);
            }

            // 解析起始颜色以提取R、G、B值
            const startColorValues = startColor.match(/\d+/g).map(Number);
            const endColorValues = endColor.match(/\d+/g).map(Number);
            const [startR, startG, startB] = startColorValues;
            const [endR, endG, endB] = endColorValues;

            // 获取颜色渐变数组
            const gradientColors = [];
            for (let i = 0; i < numSegments; i++) {
                const red = startR + (endR - startR) * i / (numSegments - 1);
                const green = startG + (endG - startG) * i / (numSegments - 1);
                const blue = startB + (endB - startB) * i / (numSegments - 1);
                const cesiumColor = rgbToCesiumColor(red, green, blue);
                gradientColors.push(cesiumColor);
            }

            return gradientColors;
        }


        function getIntervalIndex(H) {
            // 区间定义，第一个元素表示最小值，最后一个元素表示无穷大，其他值为各个区间的上限值
            const intervals = [0, 0.20, 0.50, 1.0, 1.50, 2.0, 2.5, 3, Number.POSITIVE_INFINITY];

            // 检查H是否大于最后一个区间值，如果是，则属于最后一个区间
            if (H > intervals[intervals.length - 1]) {
                return intervals.length;
            }

            // 循环遍历所有区间，找到第一个H小于等于的区间，然后返回对应的索引
            for (let i = 0; i < intervals.length; i++) {
                if (H <= intervals[i]) {
                    return i;
                }
            }

            // 如果H小于所有区间的第一个值，则属于第一个区间
            return 0;
        }

    </script>
</body>

</html>