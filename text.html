<!doctype html>
<html>

<head>
    <title>张家板桥</title>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />

    <link rel="stylesheet" type="text/css" href="./Cesium-1.96/Build/Cesium/Widgets/widgets.css">
    <script type="text/javascript" src="./Cesium-1.96/Build/Cesium/Cesium.js"></script>
    <style>
        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .cesium-widget-credits {
            display: none !important;
        }
    </style>

<body>
    <div id="cesiumcontainer" style="width:100%;height:100%"></div>

    <script type="text/javascript">
        Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlODBjMmY1YS00NjZjLTQwZjUtYTVhNy05NDBiODliYWYwMzUiLCJpZCI6MTU1ODM0LCJpYXQiOjE2OTAwOTA4MTN9.s-rWLcdw5_e2j9Fz2l41ydsl23lAVJg2Q3XhThRUeRM";

        var viewer = new Cesium.Viewer("cesiumcontainer", {
            //搜索框
            geocoder: false,
            //home键
            homeButton: false,
            // 动画控件
            animation: false,
            //全屏按钮
            fullscreenButton: false,
            //场景模式选择器
            sceneModePicker: false,
            //时间轴
            timeline: false,
            //导航提示
            navigationHelpButton: false,
            //地图选择器
            baseLayerPicker: false,
            imageryProvider: new Cesium.UrlTemplateImageryProvider({
                url: "http://webst01.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}",
                minimumLevel: 1,
                maximumLevel: 18
            }),
        })
        // viewer.imageryLayers.add(
        //     new Cesium.ImageryLayer(new Cesium.UrlTemplateImageryProvider({
        //         url: "https://wprd01.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scl=1&style=8&ltype=4",
        //         minimumLevel: 1,
        //         maximumLevel: 18
        //     }))
        // )

        // viewer.terrainProvider = new Cesium.CesiumTerrainProvider({
        //     url: "./terrain/",
        // })

        // 将视角定位到指定的经纬度
        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(113.39811, 31.699212, 4000.0), // 例如：1000
            orientation: {
                heading: Cesium.Math.toRadians(0.0), // 指定航向角度
                pitch: Cesium.Math.toRadians(-90.0), // 指定俯仰角度
                roll: 0.0 // 指定翻滚角度
            }
        })


        // 生成Cesium颜色渐变数组，从浅蓝色到深蓝色
        const numSegments = 9;
        const startColor = "rgb(149, 208, 238)";
        const endColor = "rgb(10,9,145)";

        const colorGradient = generateCesiumColorGradient(numSegments, startColor, endColor);
        console.log(colorGradient[0]);


        // 在HTML中使用Cesium的Viewer来显示场景
        var viewer = new Cesium.Viewer('cesiumContainer');

        // 读取点云数据并绘制网格
        fetch('./flood/clearcenter1.txt')
            .then(response => response.text())
            .then(data => {
                // 解析文本数据为点云数组
                var pointCloudData = parsePointCloudData(data);

                // 创建PolylineCollection
                var polylineCollection = new Cesium.PolylineCollection();

                // 添加多段折线到PolylineCollection中
                for (var i = 0; i < pointCloudData.length - 1; i++) {
                    var startPoint = pointCloudData[i];
                    var endPoint = pointCloudData[i + 1];
                    var positions = [startPoint, endPoint];

                    var polyline = new Cesium.PolylineGeometry({
                        positions: positions,
                        width: 2 // 设置网格线的宽度
                    });

                    var polylineInstance = new Cesium.GeometryInstance({
                        geometry: polyline,
                        attributes: {
                            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.RED)
                        }
                    });

                    polylineCollection.add(polylineInstance);
                }

                // 添加到场景中
                viewer.scene.primitives.add(polylineCollection);
            })
            .catch(error => {
                console.error('Failed to fetch point cloud data:', error);
            });

        // 解析点云数据文本为点云数组的函数
        function parsePointCloudData(data) {
            var lines = data.split('\n');
            var pointCloudData = [];
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var values = line.split(',');
                if (values.length === 3) {
                    var longitude = parseFloat(values[0]);
                    var latitude = parseFloat(values[1]);
                    var height = parseFloat(values[2]);
                    var cartesian = Cesium.Cartesian3.fromDegrees(longitude, latitude, height);
                    pointCloudData.push(cartesian);
                }
            }
            return pointCloudData;
        }

        // 解析点云数据文本为点云数组的函数（需要根据数据格式进行解析）
        function parsePointCloudData(data) {
            // 假设点云数据格式为每行以逗号分隔经度、纬度、高度的形式
            var lines = data.split('\n');
            var pointCloudData = [];
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                var values = line.split(',');
                if (values.length === 3) {
                    var longitude = parseFloat(values[0]);
                    var latitude = parseFloat(values[1]);
                    var height = parseFloat(values[2]);
                    pointCloudData.push([longitude, latitude, height]);
                }
            }
            return pointCloudData;
        }




        function generateCesiumColorGradient(numSegments, startColor, endColor) {
            // 将RGB颜色转换为Cesium颜色
            function rgbToCesiumColor(r, g, b) {
                return new Cesium.Color(r / 255, g / 255, b / 255);
            }

            // 解析起始颜色以提取R、G、B值
            const startColorValues = startColor.match(/\d+/g).map(Number);
            const endColorValues = endColor.match(/\d+/g).map(Number);
            const [startR, startG, startB] = startColorValues;
            const [endR, endG, endB] = endColorValues;

            // 获取颜色渐变数组
            const gradientColors = [];
            for (let i = 0; i < numSegments; i++) {
                const red = startR + (endR - startR) * i / (numSegments - 1);
                const green = startG + (endG - startG) * i / (numSegments - 1);
                const blue = startB + (endB - startB) * i / (numSegments - 1);
                const cesiumColor = rgbToCesiumColor(red, green, blue);
                gradientColors.push(cesiumColor);
            }

            return gradientColors;
        }


        function getIntervalIndex(H) {
            // 区间定义，第一个元素表示最小值，最后一个元素表示无穷大，其他值为各个区间的上限值
            const intervals = [0, 0.20, 0.50, 1.0, 1.50, 2.0, 2.5, 3, Number.POSITIVE_INFINITY];

            // 检查H是否大于最后一个区间值，如果是，则属于最后一个区间
            if (H > intervals[intervals.length - 1]) {
                return intervals.length;
            }

            // 循环遍历所有区间，找到第一个H小于等于的区间，然后返回对应的索引
            for (let i = 0; i < intervals.length; i++) {
                if (H <= intervals[i]) {
                    return i;
                }
            }

            // 如果H小于所有区间的第一个值，则属于第一个区间
            return 0;
        }

    </script>
</body>

</html>